"// SPDX-License-Identifier: MIT\r\npragma solidity 0.8.12;\r\n\r\n/// @title Multicall3\r\n/// @notice Aggregate results from multiple function calls\r\n/// @dev Multicall & Multicall2 backwards-compatible\r\n/// @dev Aggregate methods are marked `payable` to save 24 gas per call\r\n/// @author Michael Elliot <mike@makerdao.com>\r\n/// @author Joshua Levine <joshua@makerdao.com>\r\n/// @author Nick Johnson <arachnid@notdot.net>\r\n/// @author Andreas Bigger <andreas@nascent.xyz>\r\n/// @author Matt Solomon <matt@mattsolomon.dev>\r\ncontract Multicall3 {\r\n    struct Call {\r\n        address target;\r\n        bytes callData;\r\n    }\r\n\r\n    struct Call3 {\r\n        address target;\r\n        bool allowFailure;\r\n        bytes callData;\r\n    }\r\n\r\n    struct Call3Value {\r\n        address target;\r\n        bool allowFailure;\r\n        uint256 value;\r\n        bytes callData;\r\n    }\r\n\r\n    struct Result {\r\n        bool success;\r\n        bytes returnData;\r\n    }\r\n\r\n    /// @notice Backwards-compatible call aggregation with Multicall\r\n    /// @param calls An array of Call structs\r\n    /// @return blockNumber The block number where the calls were executed\r\n    /// @return returnData An array of bytes containing the responses\r\n    function aggregate(Call[] calldata calls) public payable returns (uint256 blockNumber, bytes[] memory returnData) {\r\n        blockNumber = block.number;\r\n        uint256 length = calls.length;\r\n        returnData = new bytes[](length);\r\n        Call calldata call;\r\n        for (uint256 i = 0; i < length;) {\r\n            bool success;\r\n            call = calls[i];\r\n            (success, returnData[i]) = call.target.call(call.callData);\r\n            require(success, \"Multicall3: call failed\");\r\n            unchecked { ++i; }\r\n        }\r\n    }\r\n\r\n    /// @notice Backwards-compatible with Multicall2\r\n    /// @notice Aggregate calls without requiring success\r\n    /// @param requireSuccess If true, require all calls to succeed\r\n    /// @param calls An array of Call structs\r\n    /// @return returnData An array of Result structs\r\n    function tryAggregate(bool requireSuccess, Call[] calldata calls) public payable returns (Result[] memory returnData) {\r\n        uint256 length = calls.length;\r\n        returnData = new Result[](length);\r\n        Call calldata call;\r\n        for (uint256 i = 0; i < length;) {\r\n            Result memory result = returnData[i];\r\n            call = calls[i];\r\n            (result.success, result.returnData) = call.target.call(call.callData);\r\n            if (requireSuccess) require(result.success, \"Multicall3: call failed\");\r\n            unchecked { ++i; }\r\n        }\r\n    }\r\n\r\n    /// @notice Backwards-compatible with Multicall2\r\n    /// @notice Aggregate calls and allow failures using tryAggregate\r\n    /// @param calls An array of Call structs\r\n    /// @return blockNumber The block number where the calls were executed\r\n    /// @return blockHash The hash of the block where the calls were executed\r\n    /// @return returnData An array of Result structs\r\n    function tryBlockAndAggregate(bool requireSuccess, Call[] calldata calls) public payable returns (uint256 blockNumber, bytes32 blockHash, Result[] memory returnData) {\r\n        blockNumber = block.number;\r\n        blockHash = blockhash(block.number);\r\n        returnData = tryAggregate(requireSuccess, calls);\r\n    }\r\n\r\n    /// @notice Backwards-compatible with Multicall2\r\n    /// @notice Aggregate calls and allow failures using tryAggregate\r\n    /// @param calls An array of Call structs\r\n    /// @return blockNumber The block number where the calls were executed\r\n    /// @return blockHash The hash of the block where the calls were executed\r\n    /// @return returnData An array of Result structs\r\n    function blockAndAggregate(Call[] calldata calls) public payable returns (uint256 blockNumber, bytes32 blockHash, Result[] memory returnData) {\r\n        (blockNumber, blockHash, returnData) = tryBlockAndAggregate(true, calls);\r\n    }\r\n\r\n    /// @notice Aggregate calls, ensuring each returns success if required\r\n    /// @param calls An array of Call3 structs\r\n    /// @return returnData An array of Result structs\r\n    function aggregate3(Call3[] calldata calls) public payable returns (Result[] memory returnData) {\r\n        uint256 length = calls.length;\r\n        returnData = new Result[](length);\r\n        Call3 calldata calli;\r\n        for (uint256 i = 0; i < length;) {\r\n            Result memory result = returnData[i];\r\n            calli = calls[i];\r\n            (result.success, result.returnData) = calli.target.call(calli.callData);\r\n            assembly {\r\n                // Revert if the call fails and failure is not allowed\r\n                // `allowFailure := calldataload(add(calli, 0x20))` and `success := mload(result)`\r\n                if iszero(or(calldataload(add(calli, 0x20)), mload(result))) {\r\n                    // set \"Error(string)\" signature: bytes32(bytes4(keccak256(\"Error(string)\")))\r\n                    mstore(0x00, 0x08c379a000000000000000000000000000000000000000000000000000000000)\r\n                    // set data offset\r\n                    mstore(0x04, 0x0000000000000000000000000000000000000000000000000000000000000020)\r\n                    // set length of revert string\r\n                    mstore(0x24, 0x0000000000000000000000000000000000000000000000000000000000000017)\r\n                    // set revert string: bytes32(abi.encodePacked(\"Multicall3: call failed\"))\r\n                    mstore(0x44, 0x4d756c746963616c6c333a2063616c6c206661696c6564000000000000000000)\r\n                    revert(0x00, 0x64)\r\n                }\r\n            }\r\n            unchecked { ++i; }\r\n        }\r\n    }\r\n\r\n    /// @notice Aggregate calls with a msg value\r\n    /// @notice Reverts if msg.value is less than the sum of the call values\r\n    /// @param calls An array of Call3Value structs\r\n    /// @return returnData An array of Result structs\r\n    function aggregate3Value(Call3Value[] calldata calls) public payable returns (Result[] memory returnData) {\r\n        uint256 valAccumulator;\r\n        uint256 length = calls.length;\r\n        returnData = new Result[](length);\r\n        Call3Value calldata calli;\r\n        for (uint256 i = 0; i < length;) {\r\n            Result memory result = returnData[i];\r\n            calli = calls[i];\r\n            uint256 val = calli.value;\r\n            // Humanity will be a Type V Kardashev Civilization before this overflows - andreas\r\n            // ~ 10^25 Wei in existence << ~ 10^76 size uint fits in a uint256\r\n            unchecked { valAccumulator += val; }\r\n            (result.success, result.returnData) = calli.target.call{value: val}(calli.callData);\r\n            assembly {\r\n                // Revert if the call fails and failure is not allowed\r\n                // `allowFailure := calldataload(add(calli, 0x20))` and `success := mload(result)`\r\n                if iszero(or(calldataload(add(calli, 0x20)), mload(result))) {\r\n                    // set \"Error(string)\" signature: bytes32(bytes4(keccak256(\"Error(string)\")))\r\n                    mstore(0x00, 0x08c379a000000000000000000000000000000000000000000000000000000000)\r\n                    // set data offset\r\n                    mstore(0x04, 0x0000000000000000000000000000000000000000000000000000000000000020)\r\n                    // set length of revert string\r\n                    mstore(0x24, 0x0000000000000000000000000000000000000000000000000000000000000017)\r\n                    // set revert string: bytes32(abi.encodePacked(\"Multicall3: call failed\"))\r\n                    mstore(0x44, 0x4d756c746963616c6c333a2063616c6c206661696c6564000000000000000000)\r\n                    revert(0x00, 0x84)\r\n                }\r\n            }\r\n            unchecked { ++i; }\r\n        }\r\n        // Finally, make sure the msg.value = SUM(call[0...i].value)\r\n        require(msg.value == valAccumulator, \"Multicall3: value mismatch\");\r\n    }\r\n\r\n    /// @notice Returns the block hash for the given block number\r\n    /// @param blockNumber The block number\r\n    function getBlockHash(uint256 blockNumber) public view returns (bytes32 blockHash) {\r\n        blockHash = blockhash(blockNumber);\r\n    }\r\n\r\n    /// @notice Returns the block number\r\n    function getBlockNumber() public view returns (uint256 blockNumber) {\r\n        blockNumber = block.number;\r\n    }\r\n\r\n    /// @notice Returns the block coinbase\r\n    function getCurrentBlockCoinbase() public view returns (address coinbase) {\r\n        coinbase = block.coinbase;\r\n    }\r\n\r\n    /// @notice Returns the block difficulty\r\n    function getCurrentBlockDifficulty() public view returns (uint256 difficulty) {\r\n        difficulty = block.difficulty;\r\n    }\r\n\r\n    /// @notice Returns the block gas limit\r\n    function getCurrentBlockGasLimit() public view returns (uint256 gaslimit) {\r\n        gaslimit = block.gaslimit;\r\n    }\r\n\r\n    /// @notice Returns the block timestamp\r\n    function getCurrentBlockTimestamp() public view returns (uint256 timestamp) {\r\n        timestamp = block.timestamp;\r\n    }\r\n\r\n    /// @notice Returns the (ETH) balance of a given address\r\n    function getEthBalance(address addr) public view returns (uint256 balance) {\r\n        balance = addr.balance;\r\n    }\r\n\r\n    /// @notice Returns the block hash of the last block\r\n    function getLastBlockHash() public view returns (bytes32 blockHash) {\r\n        unchecked {\r\n            blockHash = blockhash(block.number - 1);\r\n        }\r\n    }\r\n\r\n    /// @notice Gets the base fee of the given block\r\n    /// @notice Can revert if the BASEFEE opcode is not implemented by the given chain\r\n    function getBasefee() public view returns (uint256 basefee) {\r\n        basefee = block.basefee;\r\n    }\r\n\r\n    /// @notice Returns the chain id\r\n    function getChainId() public view returns (uint256 chainid) {\r\n        chainid = block.chainid;\r\n    }\r\n}"
